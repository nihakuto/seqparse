{"version":3,"file":"cli.js","mappings":"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","sources":["webpack://seqparse/./src/fetchFile.ts","webpack://seqparse/./src/index.ts","webpack://seqparse/./src/parseFile.ts","webpack://seqparse/./src/parsers/benchling.ts","webpack://seqparse/./src/parsers/biobrick.ts","webpack://seqparse/./src/parsers/fasta.ts","webpack://seqparse/./src/parsers/genbank.ts","webpack://seqparse/./src/parsers/jbei.ts","webpack://seqparse/./src/parsers/sbol.ts","webpack://seqparse/./src/parsers/sbol.v1.ts","webpack://seqparse/./src/parsers/sbol.v2.ts","webpack://seqparse/./src/parsers/seqbuilder.ts","webpack://seqparse/./src/parsers/snapgene.ts","webpack://seqparse/./src/utils.ts","webpack://seqparse/external commonjs \"fast-xml-parser\"","webpack://seqparse/external commonjs \"node-fetch\"","webpack://seqparse/external node-commonjs \"fs\"","webpack://seqparse/external node-commonjs \"path\"","webpack://seqparse/webpack/bootstrap","webpack://seqparse/./src/cli.ts"],"sourcesContent":["import fetch, { Response } from \"node-fetch\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseFile from \"./parseFile\";\n\n/**\n * Get a remote sequence from NCBI or the iGEM registry.\n */\nexport default async (accession: string, options?: ParseOptions): Promise<Seq> => {\n  // The user doesn't specify the target registry, so we have to infer it from the passed accession: iGEM or NCBI\n  let url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=${accession.trim()}&rettype=gbwithparts&retmode=text`;\n  if (accession.startsWith(\"BB\")) {\n    // it's a BioBrick... target the iGEM repo\n    if ((typeof window !== \"undefined\" && typeof process === \"undefined\") || options?.cors) {\n      // use this hack to get around a no-CORS setting on iGEM webserver, pending fix on their side\n      url = `https://cors-anywhere.herokuapp.com/http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    } else {\n      url = `http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    }\n  }\n\n  // Request the XML from the webserver\n  let body = \"\";\n  let response: Response;\n  try {\n    response = await fetch(url);\n    body = await response.text();\n  } catch (err) {\n    throw new Error(`Failed to get part: accession=${accession} url=${url} err=${err}`);\n  }\n  if (!response.ok || !body.length) {\n    throw new Error(`Failed to get part, no body returned: accession=${accession} url=${url}`);\n  }\n\n  return (await parseFile(body))[0];\n};\n\n/** returns whether the passed ID is an accession in iGEM or NCBI */\nexport const isAccession = (accession: string): boolean => {\n  if (accession.startsWith(\"BB\")) {\n    return true; // biobrick\n  }\n  if (accession.length < 14 && accession.match(/^[a-z0-9_\\-.]+$/i)) {\n    return true;\n  }\n  return false;\n};\n","import fetchFile, { isAccession } from \"./fetchFile\";\nimport parseFile from \"./parseFile\";\n\n/** Seq is a single parsed sequence from a file or accession. */\nexport interface Seq {\n  /** annotations of the sequence */\n  annotations: Annotation[];\n  /** name of the sequence */\n  name: string;\n  /** the sequence */\n  seq: string;\n  /** type of sequence. Inferred from the seq's symbols */\n  type: \"dna\" | \"rna\" | \"aa\" | \"unknown\";\n}\n\n/** Annotation is a single feature/annotation parsed from a sequence file. */\nexport interface Annotation {\n  /** color of the annotation if set */\n  color?: string;\n  /** 1 if forward, 0 if no direction, -1 if in reverse direction */\n  direction?: number;\n  /** end of the annotation, 0-based */\n  end: number;\n  /** name of the annotation */\n  name: string;\n  /** start of the annotation, 0-based */\n  start: number;\n  /** type field if set on the annotation */\n  type?: string;\n}\n\n/** Options to parse sequence files. */\nexport interface ParseOptions {\n  /**\n   * Whether to use cors-anywhere to circumvent iGEM's web server having a bad configuration.\n   */\n  cors?: boolean;\n\n  /** name of the source file */\n  fileName?: string;\n\n  /**\n   * Source of the file (ArrayBuffer). This is necessary for SnapGene.\n   *\n   * Eg after a read from FileReader.readAsArrayBuffer() in a browser:\n   * https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer\n   */\n  source?: ArrayBuffer;\n}\n\n/* Parse a sequence file. Or download a sequence with an Accession ID. */\nexport default async (input: string, options?: ParseOptions): Promise<Seq> => {\n  if (!options?.fileName && isAccession(input)) {\n    return await fetchFile(input, options);\n  }\n  return parseFile(input, options)[0];\n};\n\nexport { parseFile };\n","import { sep } from \"path\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseBenchling from \"./parsers/benchling\";\nimport parseBioBrick from \"./parsers/biobrick\";\nimport parseFasta from \"./parsers/fasta\";\nimport parseGenbank from \"./parsers/genbank\";\nimport parseJbei from \"./parsers/jbei\";\nimport parseSbol from \"./parsers/sbol\";\nimport parseSeqBuilder from \"./parsers/seqbuilder\";\nimport parseSnapgene from \"./parsers/snapgene\";\nimport { complement, guessType } from \"./utils\";\n\n/**\n * parseFile converts the contents of a sequence file to a an array of Seq\n */\nexport default (file: string, opts?: ParseOptions): Seq[] => {\n  const fileName = opts?.fileName || \"\";\n  const sourceName = fileName.split(sep).pop() || fileName;\n\n  if (!file) {\n    throw Error(\"cannot parse null or empty string\");\n  }\n\n  // this is a check for an edge case, where the user uploads come kind\n  // of file that's full of bps but doesn't fit into a defined type\n  const firstLine = file.substring(0, file.search(\"\\n\"));\n  const dnaCharLength = firstLine.replace(/[^atcgATCG]/, \"\").length;\n  const dnaOnlyFile = dnaCharLength / firstLine.length > 0.8; // is it >80% dna?\n  const name = fileName && sourceName ? sourceName.substring(0, sourceName.search(\"\\\\.\")) : \"Untitled\";\n\n  // another edge case check for whether the seq is a JSON seq from Benchling\n  // just a heuristic that says 1) yes it can be parsed 2) it contains a list of\n  // fields that are common to Benchling files\n  let isBenchling = false;\n  try {\n    const benchlingJSON = JSON.parse(file); // will err out if not JSON\n    if ([\"bases\", \"annotations\", \"primers\"].every(k => typeof benchlingJSON[k] !== \"undefined\")) {\n      isBenchling = true;\n    }\n  } catch (ex) {\n    // expected\n  }\n\n  const prefix = file.substring(0, 200);\n  let seqs: Seq[];\n  switch (true) {\n    // JBEI\n    case prefix.includes(':seq=\"http://jbei.org/sequence\"'):\n    case file.startsWith(\"<seq:seq\"):\n      seqs = parseJbei(file);\n      break;\n\n    // FASTA\n    case file.startsWith(\">\"):\n    case file.startsWith(\";\"):\n    case fileName.endsWith(\".seq\"):\n    case fileName.endsWith(\".fa\"):\n    case fileName.endsWith(\".fas\"):\n    case fileName.endsWith(\".fasta\"):\n      seqs = parseFasta(file, fileName);\n      break;\n\n    // Genbank\n    case file.includes(\"LOCUS\") && file.includes(\"ORIGIN\"):\n    case fileName.endsWith(\".gb\"):\n    case fileName.endsWith(\".gbk\"):\n    case fileName.endsWith(\".genbank\"):\n    case fileName.endsWith(\".ape\"):\n      seqs = parseGenbank(file, fileName);\n      break;\n\n    // SnapGene\n    case fileName.endsWith(\".dna\"):\n      seqs = parseSnapgene(opts);\n      break;\n\n    // SeqBuilder\n    case prefix.includes(\"Written by SeqBuilder\"):\n    case fileName.endsWith(\".sbd\"):\n      seqs = parseSeqBuilder(file, fileName);\n      break;\n\n    // BioBrick XML\n    case prefix.includes(\"Parts from the iGEM\"):\n    case prefix.includes(\"<part_list>\"):\n      seqs = parseBioBrick(file);\n      break;\n\n    // Benchling JSON\n    case isBenchling:\n      seqs = parseBenchling(file);\n      break;\n\n    // SBOL\n    case prefix.includes(\"RDF\"):\n      seqs = parseSbol(file, fileName);\n      break;\n\n    // a DNA text file without an official formatting\n    case dnaOnlyFile: {\n      const { seq } = complement(file);\n      seqs = [{ annotations: [], name, seq, type: guessType(seq) }];\n      break;\n    }\n\n    default:\n      throw Error(`${fileName} File type not recognized: ${file}`);\n  }\n\n  // bit of clean up to: only return the fields in a Seq and reorder to match expectations.\n  return seqs.map(p => ({\n    annotations: p.annotations\n      .sort((a, b) => a.start - b.start || a.end - b.end)\n      .map(a => ({\n        color: a.color,\n        direction: a.direction,\n        end: a.end,\n        name: a.name,\n        start: a.start,\n        type: a.type,\n      })),\n    name: p.name,\n    seq: p.seq,\n    type: p.type,\n  }));\n};\n","import { Seq } from \"..\";\nimport { complement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Benchling format is just JSON. It's virtually the same format.\n */\nexport default (text: string): Seq[] => {\n  const partJSON = JSON.parse(text);\n  const { seq } = complement(partJSON.bases);\n\n  // throw an error if the sequence is empty\n  if (seq.length < 1) {\n    throw new Error(\"Invalid Benchling part: empty sequence\");\n  }\n\n  return [\n    {\n      annotations: partJSON.annotations.map(a => ({\n        ...a,\n        direction: parseDirection(a.strand),\n      })),\n      name: partJSON.name || partJSON._id,\n      seq: seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Seq } from \"..\";\nimport { complement, firstElement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a BioBrick in XML format to Seq[]\n *\n * Eg: https://parts.igem.org/cgi/xml/part.cgi?part=BBa_J23100\n */\nexport default (file: string): Seq[] => {\n  const bail = (err: string) => {\n    throw new Error(`Failed on BioBrick: ${err}`);\n  };\n\n  // parse\n  const parsedBiobrick = new XMLParser({\n    isArray: name => {\n      return [\"features\", \"part_name\", \"sequences\"].includes(name);\n    },\n    removeNSPrefix: true,\n  }).parse(file);\n\n  // get the first part\n  const { part } = parsedBiobrick.rsbpml.part_list;\n  if (!part) bail(\"No part seen in part_list\");\n\n  // extract the useful fields\n  const { features, part_name, sequences } = part;\n\n  const name = firstElement(part_name);\n\n  // parse the iGEM annotations\n  const annotations = features\n    .map(({ feature }) => {\n      if (!feature) return null;\n\n      const { direction, endpos, startpos, type } = feature;\n\n      return {\n        direction: parseDirection(direction),\n        end: +endpos,\n        name: `${direction}-${startpos}`,\n        start: +startpos || 0,\n        type: type || undefined,\n      };\n    })\n    .filter(a => a);\n\n  // parse the sequence\n  const { seq } = complement(sequences[0].seq_data);\n\n  return [\n    {\n      annotations: annotations,\n      name,\n      seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","import { Seq } from \"..\";\nimport { guessType } from \"../utils\";\n\nexport default (text: string, fileName: string): Seq[] => {\n  // partFactory returns a negative \"circular\" prop, we assume they're all linear\n  if (text.trim().startsWith(\">\")) {\n    return text\n      .split(\">\") // split up if it's a multi-seq FASTA file\n      .map(t => {\n        // this starts at the end of the first line, grabs all other characters,\n        // and removes any newlines (leaving only the original sequence)\n        // sequence \"cleaning\" happens in complement (we don't support bps other than\n        // the most common right now)\n        const seq = t.substr(t.indexOf(\"\\n\"), t.length).replace(/\\s/g, \"\");\n\n        // the first line contains the name, though there's lots of variability around\n        // the information on this line...\n        // >MCHU - Calmodulin - Human, rabbit, bovine, rat, and chicken\n        const name = t.substring(0, t.search(/\\n|\\|/)).replace(/\\//g, \"\");\n\n        return {\n          annotations: [],\n          name,\n          seq,\n          type: guessType(seq),\n        };\n      })\n      .filter(p => p.name && p.seq);\n  }\n\n  if (text.trim().startsWith(\";\")) {\n    // it's an old-school style FASTA that's punctuated with semi-colons\n    // ;my|NAME\n    // ;my comment\n    // actGacgata\n    const name = text.substring(0, text.search(/\\n|\\|/)).replace(/\\//g, \"\");\n    const newlineBeforeSeq = text.indexOf(\"\\n\", text.lastIndexOf(\";\"));\n    const seq = text.substring(newlineBeforeSeq, text.length);\n    return [\n      {\n        annotations: [],\n        name,\n        seq,\n        type: guessType(seq),\n      },\n    ];\n  }\n\n  // assume that it's a no name FASTA. Ie it's just a file with dna and no header\n  // try and get the name from the fileName\n  const lastChar = fileName.lastIndexOf(\".\") || fileName.length;\n  const name = fileName.substring(0, lastChar) || \"Untitled\";\n  const seq = text;\n  return [\n    {\n      annotations: [],\n      name,\n      seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameSet = new Set([\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\", \"locus_tag\"]);\n\n// a list of tags that could represent colors\nconst tagColorSet = new Set([\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"]);\n\n/**\n * takes in a string representation of a GenBank file and outputs our\n * part representation of it. an example of a Genbank file can be found\n * at ./parsers/Gebank, though there is significant variability to the\n * format\n *\n * another official example can be found at:\n * https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html\n */\nexport default (fileInput: string, fileName: string) =>\n  fileInput\n    .split(/\\/\\/\\s/g)\n    .filter(f => f.length > 5)\n    .map(file => {\n      // the first row contains the name of the part and its creation date\n      // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n\n      // trying to avoid giving a stupid name like Exported which Snapgene has by default\n      // also, if there is not name in header, the seq length will be used as name, which should\n      // be corrected (Number.parseInt to check for this case) https://stackoverflow.com/a/175787/7541747\n      let parsedName = name;\n      if (\n        (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n        Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n      ) {\n        // first try and get the name from ACCESSION\n        let accessionName = false;\n        if (file.includes(\"ACCESSION\")) {\n          // this will be undefined is there is no\n          const accession = file\n            .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n            .replace(\".\", \"\")\n            .split(/\\s{2,}/)\n            .filter(a => a !== \"ACCESSION\")\n            .pop();\n          if (accession) {\n            parsedName = accession;\n            accessionName = true;\n          }\n        }\n\n        // otherwise, revert to trying to get the part name from the file name\n        if (!accessionName && fileName) {\n          parsedName = fileName\n            .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n            .replace(/\\/\\s/g, \"\");\n        } else if (!accessionName) {\n          parsedName = \"Unnamed\"; // give up\n        }\n      }\n\n      // the part sequence is contained in and after the line that begins with ORIGIN\n      // do this before annotations so we can calc seqlength\n      //\n      // ORIGIN\n      //    1 gatcctccat atacaacggt atctccacct caggtttaga tctcaacaac ggaaccattg\n      //    61 ccgacatgag acagttaggt atcgtcgaga gttacaagct aaaacgagca gtagtcagct\n      const SEQ_ROWS = file.substring(file.lastIndexOf(\"ORIGIN\") + \"ORIGIN\".length, file.length);\n      let seq = SEQ_ROWS.replace(/[^gatc]/gi, \"\");\n      ({ seq } = complement(seq)); // seq and compSeq\n\n      // the features are translated into annotations\n      // region is FEATURES thru ORIGIN\n      // FEATURES             Location/Qualifiers\n      //   source          1..5028\n      //                   /organism=\"Saccharomyces cerevisiae\"\n      //                   /db_xref=\"taxon:4932\"\n      //                   /chromosome=\"IX\"\n      //                   /map=\"9\"\n      //\n      // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n      // because \"db_xref\" is a recognized name type\n      // the name depends on whether the tag type is in the reocgnized list of types\n      const annotations: Annotation[] = [];\n      const primers = [];\n      if (file.indexOf(\"FEATURES\")) {\n        const FEATURES_LINE = file.indexOf(\"FEATURES\");\n        const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n        let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n        // some files have a contig file line that needs to parsed out/ shouldn't be included in\n        // the features parsing\n        if (file.includes(\"CONTIG\")) {\n          ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n        }\n        const FEATURES_ROWS = file\n          .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n          .split(/\\n/)\n          .filter(r => r);\n\n        FEATURES_ROWS.forEach(r => {\n          // in the example above, the following converts it to ['source', '1..5028']\n          const currLine = r.split(/\\s{2,}/g).filter(l => l);\n          if (currLine.length > 1) {\n            // it's the beginning of a new feature/annotation\n            const [type, rangeString] = currLine;\n            const rangeRegex = /\\d+/g;\n            const direction = r.includes(\"complement\") ? -1 : 1;\n\n            // using the example above, this parses 1..5028 into 1 and 5028\n            let [start, end] = [0, 0];\n            const startSearch = rangeRegex.exec(rangeString);\n\n            if (startSearch) {\n              // the - 1 is because genbank is 1-based while we're 0\n              start = +startSearch[0] - (1 % seq.length);\n              // single bp annotations are a thing in Genbank:\n              // https://github.com/Lattice-Automation/seqviz/issues/117\n              end = (start + 1) % seq.length;\n              const endSearch = rangeRegex.exec(rangeString);\n              if (endSearch) {\n                end = +endSearch[0] % seq.length;\n              }\n            }\n\n            if (type !== \"source\") {\n              // create a new annotation around the properties in this line (type and range)\n              annotations.push({\n                direction,\n                // set in next block\n                end,\n                name: \"\",\n                start,\n                type,\n              });\n            }\n          } else if (currLine.length === 1) {\n            // it's a continuation of a prior feature/annotation\n            // any updates (to name or color) to the last annotation should affect\n            // the last annotation that's in the array\n            if (currLine[0].startsWith(\"/\")) {\n              let [tag] = currLine;\n              tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n              // should now look like ['organism', 'Saccharomyces cerevisiae']\n              const [tagName, tagValue] = tag.split(/=/);\n\n              // the two values that can be extracted are name or color\n              const lastAnn = annotations.length - 1;\n              if (tagNameSet.has(tagName.toLowerCase())) {\n                // the key is something we recognize as an annotation name\n                if (lastAnn >= 0 && !annotations[lastAnn].name) {\n                  annotations[lastAnn].name = tagValue.trim();\n                }\n              } else if (tagColorSet.has(tagName)) {\n                // the key is something we recognize as an annotation color\n                if (lastAnn > -1) {\n                  annotations[lastAnn].color = tagValue;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return {\n        annotations: annotations,\n        name: parsedName.trim() || fileName,\n        primers: primers,\n        seq: seq,\n        type: guessType(seq),\n      };\n    });\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/**\n * Converts a JBEI file to a Seq\n *\n * https://j5.jbei.org/j5manual/pages/94.html\n */\nexport default (JBEI: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = JBEI.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedJbei = new XMLParser({\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  // destructure the parameters from JBEI\n  const { seq } = parsedJbei;\n  const { features, name, sequence } = seq;\n\n  // attempt to get the name out of the JBEI\n  let parsedName = \"Unnamed\";\n  if (name) {\n    parsedName = name;\n  }\n\n  // attempt to get the sequence. fail if it's not findable\n  const { seq: parsedSeq } = complement(sequence); // seq and compSeq\n  if (!parsedSeq) return [];\n\n  // attempt to parse the JBEI annotations into our version of annotations\n  const annotations: Annotation[] = [];\n  if (features && features.feature) {\n    features.feature.forEach(feature => {\n      if (!feature) return;\n\n      const { complement, label, location, type } = feature;\n      if (location && location.genbankStart && location.end) {\n        annotations.push({\n          direction: complement ? -1 : 1,\n          // JBEI is 1-based\n          end: +location.end || 0,\n          name: label || \"Untitled\",\n          start: +location.genbankStart - 1 || 0,\n          type: type || \"N/A\",\n        });\n      }\n    });\n  }\n\n  return [\n    {\n      annotations: annotations,\n      name: parsedName,\n      seq: parsedSeq,\n      type: guessType(parsedSeq),\n    },\n  ];\n};\n","import { Seq } from \"..\";\nimport sbolV1 from \"./sbol.v1\";\nimport sbolV2 from \"./sbol.v2\";\n\n/**\n * takes in an SBOL file in v1 or v2 format, and parses to an array of parts\n * that match the Loom data model\n */\nexport default (sbol: string, fileName: string): Seq[] =>\n  sbol.includes(\"sbols.org/v1#\") ? sbolV1(sbol) : sbolV2(sbol, fileName);\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/*\n  <sbol:Sequence rdf:about=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\">\n    <sbol:persistentIdentity rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence\"/>\n    <sbol:displayId>A1_sequence</sbol:displayId>\n    <sbol:version>1</sbol:version>\n    <prov:wasDerivedFrom rdf:resource=\"https://github.com/CIDARLAB/cello/blob/master/resources/UCF/Eco1C1G1T0.UCF.json\"/>\n    <prov:wasGeneratedBy rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/cello2sbol/1\"/>\n    <dcterms:title>A1_sequence</dcterms:title>\n    <sbh:ownedBy rdf:resource=\"https://synbiohub.cidarlab.org/user/prash\"/>\n    <sbh:topLevel rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\"/>\n    <sbol:elements>AATGTTCCCTAATAATCAGCAAAGAGGTTACTAG</sbol:elements>\n    <sbol:encoding rdf:resource=\"http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html\"/>\n  </sbol:Sequence>\n*/\n\n/**\n * takes an SBOL file, as a string, and converts it into our DB\n * representation of a part(s). an example of this type of file can be\n * found in ../examples/j5.SBOL.xml\n */\nexport default (sbol: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = sbol.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedSBOL = new XMLParser({\n    ignoreAttributes: false,\n    isArray: name =>\n      [\n        \"Sequence\",\n        \"Collection\",\n        \"DnaComponent\",\n        \"dnaSequence\",\n        \"ComponentDefinition\",\n        \"SequenceAnnotation\",\n        \"sequenceAnnotation\",\n        \"elements\",\n        \"component\",\n        \"annotation\",\n      ].includes(name),\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  let RDF = null;\n  if (parsedSBOL.RDF) ({ RDF } = parsedSBOL);\n\n  // @ts-expect-error ts-migrate(2339) FIXME: Property 'Collection' does not exist on type 'null... Remove this comment to see the full error message\n  const { Collection, DnaComponent } = RDF;\n  if (Collection && Collection.length) {\n    // it's a collection of DnaComponents, parse each to a part\n    const partList = [];\n    Collection.forEach(({ component }) => {\n      if (component && component.length) {\n        component.forEach(({ DnaComponent: nestedDnaComponent }) => {\n          partList.push(\n            // @ts-expect-error ts-migrate(2345) FIXME: Argument of type '{ seq: string; compSeq: string; ... Remove this comment to see the full error message\n            dnaComponentToPart(nestedDnaComponent[0], {\n              file: sbol,\n              strict: false,\n            })\n          );\n        });\n      }\n    });\n\n    // check whether any parts were created from the collection\n    if (partList.length) return partList;\n  } else if (DnaComponent && DnaComponent.length) {\n    // create a single part from the single one passed\n    const validPart = dnaComponentToPart(DnaComponent[0], {\n      file: sbol,\n      strict: false,\n    });\n    // it will be null if there isn't any sequence information beneath it\n    if (validPart) return [validPart];\n  }\n\n  // go on a fishing expedition for DnaComponents\n  // everything else has failed\n  // accumulate all that are \"valid\" (name + seq)\n  const dnaComponentAccumulator = [];\n  findDnaComponentNodes(dnaComponentAccumulator, RDF);\n\n  // @ts-ignore\n  const attemptedSeqs: Seq[] = dnaComponentAccumulator\n    .map(p =>\n      dnaComponentToPart(p, {\n        file: sbol,\n        strict: true,\n      })\n    )\n    .filter(p => !!p); // invalid parts will be null\n  if (attemptedSeqs.length) return attemptedSeqs;\n\n  // go on another fishing expedition, but for Sequence nodes\n  const dnaSequenceAccumulator = [];\n  findSequenceNodes(dnaSequenceAccumulator, RDF);\n  return dnaSequenceAccumulator.map(p => sequenceToPart(p, sbol)).filter(p => p); // invalid parts will be null\n};\n\n/**\n * find all the nodes within the JSON document that are keyed \"Sequence\"\n *\n * this is another last-resort scrapper for trying to find valid parts\n */\nconst findSequenceNodes = (acc, doc) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"Sequence\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findSequenceNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n\n/**\n * after getting a DnaComponent out of the SBOL document,\n * at either the root RDF level or from within a Collection/Annotation\n * hierarchy, convert that DnaComponent to a Seq\n */\nconst dnaComponentToPart = (DnaComponent, options) => {\n  const { strict = false } = options;\n  // destructure the params from DnaComponent\n  const { annotation, displayId, dnaSequence, name } = DnaComponent;\n\n  // attempt to get the name out of the SBOL\n  let parsedName = \"Unnamed\";\n  if (name) {\n    parsedName = name;\n  } else if (displayId) {\n    parsedName = displayId;\n  } else if (strict) {\n    // in this scenario, we're really scrapping to find parts, but shouldn't\n    // accept any that don't at least have some name and sequence information\n    return null;\n  }\n\n  // attempt to get the sequence. fail if it's not findable\n  let seq = \"\";\n  if (dnaSequence && dnaSequence[0].DnaSequence) {\n    seq = dnaSequence[0].DnaSequence.nucleotides;\n  }\n\n  const { seq: parsedSeq } = complement(seq); // seq and compSeq\n  if (!parsedSeq) return null;\n\n  // attempt to parse the SBOL annotations into our version of annotations\n  const annotations: Annotation[] = [];\n  if (annotation) {\n    annotation.forEach(({ SequenceAnnotation }) => {\n      if (!SequenceAnnotation || !SequenceAnnotation[0]) return;\n\n      const { bioEnd, bioStart, strand, subComponent } = SequenceAnnotation[0];\n      if (subComponent && subComponent.DnaComponent && subComponent.DnaComponent[0]) {\n        const { displayId: annId, name: annName, type: annType } = subComponent.DnaComponent[0];\n\n        annotations.push({\n          direction: strand === \"+\" ? 1 : -1,\n          end: bioEnd - 1 || 0,\n          name: annName || annId || \"Untitled\",\n          start: bioStart - 1 || 0,\n          type: annType[\"@_resource\"] || \"N/A\",\n        });\n      }\n    });\n  }\n\n  return {\n    annotations: annotations,\n    name: parsedName,\n    seq: parsedSeq,\n    type: guessType(seq),\n  };\n};\n\n/**\n * find all nodes that of the type Sequence, and convert those to parts \"Sequence\" -> Part\n *\n * this is not the standard format. see A1.xml\n */\nconst sequenceToPart = (Seq, file) => {\n  // get the name\n  const name = Seq.displayId || Seq.title || \"Unnamed\";\n\n  // get the sequence\n  const seqOrig = Seq.elements[0] || \"\";\n\n  const { compSeq, seq } = complement(seqOrig);\n\n  // guess whether it's circular or not based on the presence of a word like vector.\n  // very ad hoc\n  const circular = file.search(/plasmid/i) > 0;\n\n  return { annotations: [], circular, compSeq, name, seq, type: guessType(seq) };\n};\n\n/**\n * find all the nodes within the SBOL JSON document that are keyed \"DnaComponent\"\n *\n * this is a last-resort scrapper that tries to find valid parts that aren't within a root\n * DnaComponent document or within a root Collection array\n */\nconst findDnaComponentNodes = (acc: Seq[], doc: any) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"DnaComponent\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findDnaComponentNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/**\n * Converts an SBOL file to our Seq format.\n *\n * SBOL v2.0 schema definition can be found at: http://sbolstandard.org/wp-content/uploads/2016/06/SBOL-data-model-2.2.1.pdf\n * differs from SBOL v1.0 in that the ComponentDefinitions are like the root parts,\n * and the sequence and annotations are separated (they're no longer defined relationally\n * by nesting but, instead, by id) we only care about components that have sequence information\n */\nexport default (sbol: string, fileName: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = sbol.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedSBOL = new XMLParser({\n    ignoreAttributes: false,\n    isArray: name =>\n      [\"Sequence\", \"ComponentDefinition\", \"SequenceAnnotation\", \"sequenceAnnotation\", \"elements\"].includes(name),\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  try {\n    const seqList = parseSBOL2(parsedSBOL, fileName);\n\n    if (seqList.length) {\n      return seqList;\n    } else {\n      throw new Error(\"No Sequence info found\");\n    }\n  } catch (err) {\n    throw new Error(`Failed to parse SBOL v2 file: ${err}`);\n  }\n};\n\nconst parseSBOL2 = (parsedSBOL, fileName: string): Seq[] => {\n  let RDF = null;\n  if (parsedSBOL.RDF) {\n    ({ RDF } = parsedSBOL);\n  }\n\n  if (!RDF) {\n    throw new Error(\"No root RDF document\");\n  }\n\n  // check if anything is defined, return if not\n  const { ComponentDefinition, Sequence } = RDF;\n  if (!ComponentDefinition && !Sequence) {\n    throw new Error(\"Failed to parse SBOL v2: No ComponentDefinition or Sequence\");\n  }\n\n  // read thru the Sequence elements\n  const getSeq = (seqID?: string) => {\n    const seqElement = seqID\n      ? // @ts-ignore\n        Sequence.find(\n          s =>\n            (s.persistentIdentity && s.persistentIdentity.length && s.persistentIdentity[\"@_resource\"] === seqID) ||\n            s[\"@_about\"] === seqID\n        )\n      : Sequence[0];\n\n    if (seqElement && seqElement.elements) {\n      const { seq } = complement(seqElement.elements[0] || \"\");\n      return {\n        annotations: [],\n        name: seqElement.displayId,\n        seq,\n        type: guessType(seq),\n      };\n    }\n    return null;\n  };\n\n  // if it's a collection of DnaComponents, parse each to a part\n  const seqList: Seq[] = [];\n  // @ts-ignore\n  ComponentDefinition?.forEach((c, i) => {\n    // we're only making parts out of those with seq info\n    if (!c.sequence) {\n      return;\n    }\n\n    const { displayId, sequence, sequenceAnnotation } = c;\n    const name = displayId || `${fileName}_${i + 1}`;\n\n    const annotations: Annotation[] = [];\n    (sequenceAnnotation || []).forEach(({ SequenceAnnotation }) => {\n      const ann = SequenceAnnotation[0];\n      const annId = ann.displayId;\n      const { Range } = ann.location;\n\n      const range = Range;\n      if (range) {\n        annotations.push({\n          end: range.end - 1,\n          name: annId,\n          start: range.start - 1,\n        });\n      }\n    });\n\n    const seq = getSeq(sequence[\"@_resource\"]);\n\n    if (seq) {\n      seqList.push({\n        annotations,\n        name,\n        seq: seq.seq,\n        type: seq.type,\n      });\n    }\n  });\n\n  // if it's a single sequence, just try and get the sequence from that alone\n  const seq = getSeq();\n  if (!seqList.length && seq) {\n    seqList.push(seq);\n  }\n  return seqList;\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameList = [\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\"];\n\n// a list of tags that could represent colors\nconst tagColorList = [\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"];\n\n/**\n * takes in a string representation of a SeqBuilder file and outputs our\n * part representation of it. an example of a SeqBuilder file can be found\n * at imports/io/examples/seqbuilder, though there may be variations to the\n * format\n */\nexport default (fileInput: string, fileName: string) =>\n  fileInput.split(/\\/\\/\\s/g).map(file => {\n    // +++++SEQUENCE+++++//\n    // the part sequence comes after the line that specifies the seqbuilder version number\n    // @ts-ignore\n    const SEQ_ROWS = file\n      .substring(\n        file.search(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i) +\n          // @ts-ignore\n          file.match(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i)[0].length,\n        file.length\n      )\n      .match(/[actgyrwskmdvhbxn]+/gim)[0];\n\n    let seq = SEQ_ROWS;\n    ({ seq } = complement(seq)); // seq and compSeq\n    // there may be a genbank-like header row after the sequence\n    // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n    let parsedName = fileName.length > 0 ? fileName : \"Unnamed\";\n\n    if (~file.indexOf(\"LOCUS\")) {\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      if (HEADER_ROW && HEADER_ROW.split(/\\s{2,}/g)) {\n        const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n        parsedName = name;\n      }\n    }\n    // Name setting logic ported from GenBank parser\n    if (\n      (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n      Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n    ) {\n      // first try and get the name from ACCESSION\n      let accessionName = false;\n      if (file.includes(\"ACCESSION\")) {\n        // this will be undefined is there is no\n        const accession = file\n          .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n          .replace(\".\", \"\")\n          .split(/\\s{2,}/)\n          .filter(a => a !== \"ACCESSION\")\n          .pop();\n        if (accession) {\n          parsedName = accession;\n          accessionName = true;\n        }\n      }\n\n      // otherwise, revert to trying to get the part name from the file name\n      if (!accessionName && fileName) {\n        parsedName = fileName\n          .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n          .replace(/\\/\\s/g, \"\");\n      } else if (!accessionName) {\n        parsedName = \"Unnamed\"; // give up\n      }\n    }\n\n    // +++++ANNOTATIONS+++++//\n    // the features are translated into annotations\n    // region is FEATURES thru ORIGIN\n    // FEATURES             Location/Qualifiers\n    //   source          1..5028\n    //                   /organism=\"Saccharomyces cerevisiae\"\n    //                   /db_xref=\"taxon:4932\"\n    //                   /chromosome=\"IX\"\n    //                   /map=\"9\"\n    //\n    // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n    // because \"db_xref\" is a recognized name type\n    // the name depends on whether the tag type is in the reocgnized list of types\n    const annotations: Annotation[] = [];\n    if (file.indexOf(\"FEATURES\")) {\n      const FEATURES_LINE = file.indexOf(\"FEATURES\");\n      const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n      let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n      // some files have a contig file line that needs to parsed out/ shouldn't be included in\n      // the features parsing\n      if (file.includes(\"CONTIG\")) {\n        ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n      }\n      const FEATURES_ROWS = file\n        .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n        .split(/\\n/)\n        .filter(r => r);\n\n      FEATURES_ROWS.forEach(r => {\n        // in the example above, the following converts it to ['source', '1..5028']\n        const currLine = r.split(/\\s{2,}/g).filter(l => l);\n        if (currLine.length > 1) {\n          // it's the beginning of a new feature/annotation\n          const [type, rangeString] = currLine;\n          const rangeRegex = /\\d+/g;\n          const direction = r.includes(\"complement\") ? -1 : 1;\n\n          // using the example above, this parses 1..5028 into 1 and 5028\n          let [start, end] = [0, 0];\n          const startSearch = rangeRegex.exec(rangeString);\n\n          if (startSearch) {\n            // the - 1 is because genbank is 1-based while we're 0\n            start = +startSearch[0] - (1 % seq.length);\n            const endSearch = rangeRegex.exec(rangeString);\n            if (endSearch) {\n              end = +endSearch[0] % seq.length;\n            }\n          }\n\n          if (type !== \"source\") {\n            // source would just be an annotation for the entire sequence so remove\n            // create a new annotation around the properties in this line (type and range)\n            annotations.push({\n              direction,\n              end,\n              name: \"\",\n              start,\n              type,\n            });\n          }\n        } else if (currLine.length === 1) {\n          // it's a continuation of a prior feature/annotation\n          // any updates (to name or color) to the last annotation should affect\n          // the last annotation that's in the array\n          let [tag] = currLine;\n          tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n          // should now look like ['organism', 'Saccharomyces cerevisiae']\n          const [tagName, tagValue] = tag.split(/=/);\n\n          // the two values that can be extracted are name or color\n          const lastAnnIndex = annotations.length - 1;\n          if (tagNameList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation name\n            if (lastAnnIndex > -1 && !annotations[annotations.length - 1].name) {\n              // defensively check that there isn't already a defined annotation w/o a name\n              annotations[annotations.length - 1].name = tagValue.trim();\n            }\n          } else if (tagColorList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation color\n            if (lastAnnIndex > -1) {\n              // defensively check that there's already been a defined annotation\n              annotations[annotations.length - 1].color = tagValue;\n            }\n          }\n        }\n      });\n    }\n\n    return {\n      annotations: annotations,\n      name: parsedName.trim() || fileName,\n      seq: seq,\n      type: guessType(seq),\n    };\n  });\n","import { XMLParser } from \"fast-xml-parser\";\nimport { sep } from \"path\";\n\nimport { Annotation, ParseOptions, Seq } from \"..\";\nimport { guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a SnapGene file to Seq[]\n *\n * this is adapted from https://github.com/TeselaGen/ve-sequence-parsers/blob/master/src/parsers/snapgeneToJson.js\n * which was adapted from https://github.com/IsaacLuo/SnapGeneFileReader/blob/master/snapgene_reader/snapgene_reader.py\n */\nexport default (options?: ParseOptions): Seq[] => {\n  if (!options || !options.source) {\n    throw new Error(\"Failed to parse SnapGene file. No valid file input\");\n  }\n\n  const fileName = options?.fileName || \"\";\n  const seq = {\n    annotations: [] as Annotation[],\n    circular: false,\n    name: \"\",\n    seq: \"\",\n    type: \"unknown\",\n  };\n\n  const buffer = Buffer.from(options.source);\n\n  // Accumulate an offset from the start as we read through the file\n  let offset = 0;\n\n  // Read a buffer from the buffer\n  const read = (size: number) => {\n    const start = offset;\n    offset += size;\n    return buffer.subarray(start, offset);\n  };\n\n  // Read from buffer and decode as string\n  const readEnc = (size: number, fmt: BufferEncoding) => read(size).toString(fmt);\n\n  // Read the first byte\n  read(1);\n\n  // Read document properties\n  const length = read(4).readUInt32BE();\n  const title = readEnc(8, \"ascii\");\n  if (length !== 14 || title !== \"SnapGene\") {\n    throw new Error(`Wrong format for a SnapGene file: length=${length} title=${title}`);\n  }\n\n  read(2); // isDNA\n  read(2); // exportVersion\n  read(2); // importVersion\n\n  /* eslint-disable no-await-in-loop */\n  // READ THE WHOLE FILE, BLOCK BY BLOCK, UNTIL THE END\n  while (offset < buffer.length) {\n    // next_byte table\n    // 0: dna sequence\n    // 1: compressed DNA\n    // 2: unknown\n    // 3: unknown\n    // 5: primers\n    // 6: notes\n    // 7: history tree\n    // 8: additional sequence properties segment\n    // 9: file Description\n    // 10: features\n    // 11: history node\n    // 13: unknown\n    // 16: alignable sequence\n    // 17: alignable sequence\n    // 18: sequence trace\n    // 19: Uracil Positions\n    // 20: custom DNA colors\n\n    const nextByte = read(1);\n    const blockSize = read(4).readUInt32BE();\n    const ord = nextByte.toString().charCodeAt(0);\n    if (ord === 0) {\n      // Read the sequence and its properties\n      read(1); // isCircular\n\n      const size = blockSize - 1;\n      if (size < 0) throw new Error(\"Failed parsing SnapGene: < 0 length sequence\");\n      seq.seq = readEnc(size, \"ascii\");\n    } else if (ord === 10) {\n      // Read all the features\n      const xml = readEnc(blockSize, \"utf8\") as string;\n      const b = new XMLParser({\n        attributeNamePrefix: \"\",\n        ignoreAttributes: false,\n        isArray: name => name === \"Q\" || name === \"Segment\",\n        removeNSPrefix: true,\n      }).parse(xml);\n\n      b.Features.Feature.forEach(feature => {\n        let minStart = 0;\n        let maxEnd = 0;\n        const { range } = feature.Segment[0];\n        const [start, end] = range.split(\"-\");\n        minStart = minStart === 0 ? +start : Math.min(minStart, +start);\n        maxEnd = Math.max(maxEnd, +end);\n\n        // create an Annotation\n        seq.annotations.push({\n          direction: parseDirection(\n            {\n              \"0\": \"NONE\",\n              \"1\": 1,\n              \"2\": -1,\n              \"3\": \"BIDIRECTIONAL\",\n              undefined: \"NONE\",\n            }[feature.directionality]\n          ),\n          end: maxEnd - 1,\n          name: feature.name,\n          start: minStart - 1,\n          type: feature.type,\n        });\n      });\n    } else {\n      // UNKNOWN: WE IGNORE THE WHOLE BLOCK\n      read(blockSize);\n    }\n  }\n\n  return [\n    {\n      ...seq,\n      // SnapGene uses the filename as the sequence name\n      name: fileName.split(sep).pop()?.replace(\".dna\", \"\") || fileName,\n      type: guessType(seq.seq),\n    },\n  ];\n};\n","// from http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html\nconst comp = {\n  A: \"T\",\n  B: \"V\",\n  C: \"G\",\n  D: \"H\",\n  G: \"C\",\n  H: \"D\",\n  K: \"M\",\n  M: \"K\",\n  N: \"N\",\n  R: \"Y\",\n  S: \"S\",\n  T: \"A\",\n  U: \"A\",\n  V: \"B\",\n  W: \"W\",\n  X: \"X\",\n  Y: \"R\",\n  a: \"t\",\n  b: \"v\",\n  c: \"g\",\n  d: \"h\",\n  g: \"c\",\n  h: \"d\",\n  k: \"m\",\n  m: \"k\",\n  n: \"n\",\n  r: \"y\",\n  s: \"s\",\n  t: \"a\",\n  u: \"a\",\n  v: \"b\",\n  w: \"w\",\n  x: \"x\",\n  y: \"r\",\n};\n\n/**\n * Return the filtered sequence and its complement if its an empty string, return the same for both.\n */\nexport const complement = (origSeq: string): { compSeq: string; seq: string } => {\n  if (!origSeq) {\n    return { compSeq: \"\", seq: \"\" };\n  }\n\n  // filter out unrecognized basepairs and build up the complement\n  let seq = \"\";\n  let compSeq = \"\";\n  for (let i = 0, origLength = origSeq.length; i < origLength; i += 1) {\n    if (comp[origSeq[i]]) {\n      seq += origSeq[i];\n      compSeq += comp[origSeq[i]];\n    }\n  }\n  return { compSeq, seq };\n};\n\n/**\n * Return the reverse complement of a DNA sequence\n */\nexport const reverseComplement = (inputSeq: string): string => {\n  const { compSeq } = complement(inputSeq);\n  return compSeq.split(\"\").reverse().join(\"\");\n};\n\nexport const firstElement = (arr: any) => {\n  if (!Array.isArray(arr)) return undefined;\n  return arr[0];\n};\n\nconst fwd = new Set([\"FWD\", \"fwd\", \"FORWARD\", \"forward\", \"FOR\", \"for\", \"TOP\", \"top\", \"1\", 1]);\nconst rev = new Set([\"REV\", \"rev\", \"REVERSE\", \"reverse\", \"BOTTOM\", \"bottom\", \"-1\", -1]);\n\n/**\n * Parse the user defined direction, estimate the direction of the element\n *\n * ```js\n * parseDirection(\"FWD\") => 1\n * parseDirection(\"FORWARD\") => 1\n * ```\n */\nexport const parseDirection = (direction: number | string | undefined): -1 | 0 | 1 => {\n  if (!direction) {\n    return 0;\n  }\n  if (fwd.has(direction)) {\n    return 1;\n  }\n  if (rev.has(direction)) {\n    return -1;\n  }\n  return 0;\n};\n\n/**\n * mapping the 64 standard codons to amino acids\n * no synth AA's\n *\n * adapted from: \"https://github.com/keithwhor/NtSeq/blob/master/lib/nt.js\n */\nconst codon2AA = {\n  AAA: \"K\",\n  AAC: \"N\",\n  AAG: \"K\",\n  AAT: \"N\",\n  ACA: \"T\",\n  ACC: \"T\",\n  ACG: \"T\",\n  ACT: \"T\",\n  AGA: \"R\",\n  AGC: \"S\",\n  AGG: \"R\",\n  AGT: \"S\",\n  ATA: \"I\",\n  ATC: \"I\",\n  ATG: \"M\",\n  ATT: \"I\",\n  CAA: \"Q\",\n  CAC: \"H\",\n  CAG: \"Q\",\n  CAT: \"H\",\n  CCA: \"P\",\n  CCC: \"P\",\n  CCG: \"P\",\n  CCT: \"P\",\n  CGA: \"R\",\n  CGC: \"R\",\n  CGG: \"R\",\n  CGT: \"R\",\n  CTA: \"L\",\n  CTC: \"L\",\n  CTG: \"L\",\n  CTT: \"L\",\n  GAA: \"E\",\n  GAC: \"D\",\n  GAG: \"E\",\n  GAT: \"D\",\n  GCA: \"A\",\n  GCC: \"A\",\n  GCG: \"A\",\n  GCT: \"A\",\n  GGA: \"G\",\n  GGC: \"G\",\n  GGG: \"G\",\n  GGT: \"G\",\n  GTA: \"V\",\n  GTC: \"V\",\n  GTG: \"V\",\n  GTT: \"V\",\n  TAA: \"*\",\n  TAC: \"Y\",\n  TAG: \"*\",\n  TAT: \"Y\",\n  TCA: \"S\",\n  TCC: \"S\",\n  TCG: \"S\",\n  TCT: \"S\",\n  TGA: \"*\",\n  TGC: \"C\",\n  TGG: \"W\",\n  TGT: \"C\",\n  TTA: \"L\",\n  TTC: \"F\",\n  TTG: \"L\",\n  TTT: \"F\",\n};\n\nconst aminoAcids = Array.from(new Set(Object.values(codon2AA)).values()).join(\"\");\nconst aminoAcidRegex = new RegExp(`^[${aminoAcids}]+$`, \"i\");\n\n/** Infer the type of a sequence. This only allows a couple wildcard characters so may be overly strict. */\nexport const guessType = (seq: string): \"dna\" | \"rna\" | \"aa\" | \"unknown\" => {\n  if (/^[atgcn.]+$/i.test(seq)) {\n    return \"dna\";\n  } else if (/^[augcn.]+$/i.test(seq)) {\n    return \"rna\";\n  } else if (aminoAcidRegex.test(seq)) {\n    return \"aa\";\n  }\n  return \"unknown\";\n};\n","module.exports = require(\"fast-xml-parser\");","module.exports = require(\"node-fetch\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","#!/usr/bin/env node\nimport { existsSync, readFileSync } from \"fs\";\n\nimport seqparse, { ParseOptions } from \".\";\n\n/** a crappy but dependency-free log implementation */\nconst LOG_LEVEL = process.env.LOG_LEVEL || \"info\";\nconst debug = (msg: string) => {\n  if (LOG_LEVEL.toLowerCase() !== \"debug\") {\n    return;\n  }\n  console.log(`[DEBUG] ${msg}`);\n};\n\n/** bail, log an example */\nconst exit = () => {\n  console.error(`# Example USAGE:\n\n# parse a file\nseqparse gene.fa\n\n# parse a file from stdin\ncat gene.fa | seqparse\n\n# fetch and parse a file from NCBI of iGEM by accession\nseqparse FJ172221`);\n  process.exit(1);\n};\n\n/** input can be a file name as first arg or stdin */\nconst parseOptions = {} as ParseOptions;\n\nlet input: string | null = null;\nif (process.argv[2]) {\n  input = process.argv[2];\n  debug(\"reading from arg\");\n} else {\n  debug(\"reading from stdin\");\n  try {\n    parseOptions.source = readFileSync(process.stdin.fd);\n    parseOptions.fileName = \"Unknown\";\n    input = (parseOptions.source as Buffer).toString(\"utf-8\");\n    debug(\"successfully read stdin\");\n  } catch (err) {\n    // only a debug here because am assuming the user just didn't pass anything\n    debug(\"failed to read stdin\");\n    exit();\n  }\n}\n\n/** throw, no input detected */\nif (!input || !input.length) {\n  console.error(\"no input detected\");\n  exit();\n  process.exit(1);\n}\n\n/** check if file, if so, read */\nconst isFile = existsSync(input);\n\nlet fileContents: string | null = null;\nif (isFile) {\n  parseOptions.fileName = input;\n  try {\n    debug(\"attempting to read file\");\n    parseOptions.source = readFileSync(input);\n    fileContents = (parseOptions.source as Buffer).toString(\"utf-8\");\n    debug(\"successfully read file\");\n  } catch (err) {\n    console.error(\"failed to read file\", err);\n    exit();\n  }\n}\n\n/** parse, write to stdout */\ndebug(\"parsing\");\nseqparse(fileContents || input, parseOptions)\n  .then(r => {\n    debug(\"successfully parsed\");\n    console.log(JSON.stringify(r, null, 2));\n  })\n  .catch(err => {\n    console.error(\"failed to parse input\", err);\n    exit();\n  });\n"],"names":["accession","options","url","trim","startsWith","window","process","cors","body","response","text","Error","ok","length","isAccession","match","parseFile","input","fileName","file","opts","sourceName","split","sep","pop","firstLine","substring","search","dnaOnlyFile","replace","name","isBenchling","JSON","parse","every","k","ex","seqs","prefix","includes","endsWith","seq","complement","annotations","type","guessType","map","p","sort","a","b","start","end","color","direction","partJSON","bases","parseDirection","strand","_id","parsedBiobrick","XMLParser","isArray","removeNSPrefix","part","rsbpml","part_list","err","bail","features","part_name","sequences","firstElement","feature","endpos","startpos","undefined","filter","seq_data","t","substr","indexOf","newlineBeforeSeq","lastIndexOf","lastChar","tagNameSet","Set","tagColorSet","fileInput","f","parsedName","h","Number","parseInt","accessionName","Math","max","FEATURES_LINE","FEATURES_NEW_LINE","ORIGIN_LINE","min","r","forEach","currLine","l","rangeString","rangeRegex","startSearch","exec","endSearch","push","tag","tagName","tagValue","lastAnn","has","toLowerCase","primers","JBEI","fileString","sequence","parsedSeq","label","location","genbankStart","sbol","parsedSBOL","ignoreAttributes","RDF","Collection","DnaComponent","component","nestedDnaComponent","dnaComponentToPart","strict","validPart","dnaComponentAccumulator","findDnaComponentNodes","attemptedSeqs","dnaSequenceAccumulator","findSequenceNodes","sequenceToPart","acc","doc","Object","keys","Array","nestedNode","annotation","displayId","dnaSequence","DnaSequence","nucleotides","SequenceAnnotation","bioEnd","bioStart","subComponent","annId","annName","annType","Seq","title","seqOrig","elements","compSeq","circular","seqList","parseSBOL2","ComponentDefinition","Sequence","getSeq","seqID","seqElement","find","s","persistentIdentity","c","i","sequenceAnnotation","ann","range","tagNameList","tagColorList","HEADER_ROW","lastAnnIndex","source","buffer","Buffer","from","offset","read","size","subarray","readEnc","fmt","toString","readUInt32BE","nextByte","blockSize","ord","charCodeAt","xml","attributeNamePrefix","Features","Feature","minStart","maxEnd","Segment","directionality","comp","A","B","C","D","G","H","K","M","N","R","S","T","U","V","W","X","Y","d","g","m","n","u","v","w","x","y","origSeq","origLength","reverseComplement","inputSeq","reverse","join","arr","fwd","rev","aminoAcids","values","AAA","AAC","AAG","AAT","ACA","ACC","ACG","ACT","AGA","AGC","AGG","AGT","ATA","ATC","ATG","ATT","CAA","CAC","CAG","CAT","CCA","CCC","CCG","CCT","CGA","CGC","CGG","CGT","CTA","CTC","CTG","CTT","GAA","GAC","GAG","GAT","GCA","GCC","GCG","GCT","GGA","GGC","GGG","GGT","GTA","GTC","GTG","GTT","TAA","TAC","TAG","TAT","TCA","TCC","TCG","TCT","TGA","TGC","TGG","TGT","TTA","TTC","TTG","TTT","aminoAcidRegex","RegExp","test","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","LOG_LEVEL","env","debug","msg","console","log","exit","error","parseOptions","argv","readFileSync","stdin","fd","fileContents","existsSync","then","stringify","catch"],"sourceRoot":""}